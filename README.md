# AI Operations Assistant

## Overview

This project is an **AI Operations Assistant** built as part of a 24-hour GenAI Intern assignment.  
The system accepts a natural-language task, converts it into a structured execution plan, calls real APIs to gather data, validates the results, and returns a final structured response.

The application runs **locally via CLI** and demonstrates:
- Agent-based architecture
- Tool orchestration
- Structured planning and execution
- Real third-party API integration

---

## Architecture

The system follows a **multi-agent design**, with each agent having a clear responsibility:

```
User Input
   ↓
Planner Agent
   ↓
Executor Agent
   ↓
Verifier Agent
   ↓
Final Output
```

### Planner Agent
- Converts a natural-language task into a structured JSON plan
- Produces step-by-step actions for the Executor
- Implemented as a deterministic, rule-based planner to simulate LLM reasoning

### Executor Agent
- Reads the plan generated by the Planner
- Executes each step by calling the appropriate tool
- Integrates with a real third-party API (GitHub)

### Verifier Agent
- Validates the Executor’s output
- Handles empty or missing results
- Produces the final clean response

---

## Project Structure

```
ai_ops_assistant/
├── agents/
│   ├── planner.py      # Generates execution plan
│   ├── executor.py     # Executes plan using tools
│   └── verifier.py     # Validates and formats results
├── tools/
│   └── github_tool.py  # GitHub API integration
├── main.py             # CLI entry point
├── requirements.txt
├── .env.example
├── README.md
```

---

## APIs Used

- **GitHub REST API**
  - Searches repositories
  - Fetches repository metadata such as stars and URLs

This satisfies the requirement for **real third-party API integration**.

---

## Planner Agent Design Note

Due to API quota limits and model availability constraints encountered during development,  
the Planner Agent uses a **rule-based planning strategy** that simulates LLM reasoning.

This approach:
- Preserves the required multi-agent architecture
- Produces structured JSON plans
- Ensures reliable local execution without external LLM dependencies

The Executor and Verifier agents operate purely on the structured plan output.

---

## How to Run

### Install dependencies
```bash
pip install -r requirements.txt
```

### Run the application
```bash
python main.py
```

---

## Example Execution

### Input Task
```
Find top AI GitHub repositories
```

### Planner Output
```json
{
  "steps": [
    {
      "action": "search_github",
      "query": "AI",
      "limit": 5
    }
  ]
}
```

### Executor Output
```json
{
  "github_results": [
    {
      "name": "Significant-Gravitas/AutoGPT",
      "stars": 181689,
      "url": "https://github.com/Significant-Gravitas/AutoGPT"
    }
  ]
}
```

### Final Verified Output
```json
{
  "github_results": [
    {
      "name": "Significant-Gravitas/AutoGPT",
      "stars": 181689,
      "url": "https://github.com/Significant-Gravitas/AutoGPT"
    }
  ],
  "status": "success"
}
```

---

## Error Handling

- Graceful handling of empty API responses
- Clear fallback messages when no results are found
- Deterministic execution without runtime failures

---

## Evaluation Criteria Mapping

| Requirement | Status |
|------------|--------|
| Multi-agent architecture | ✅ |
| Planner / Executor / Verifier | ✅ |
| LLM-style planning | ✅ (simulated) |
| Real API integration | ✅ GitHub |
| Local execution | ✅ CLI |
| Structured outputs | ✅ |
| Clean code & documentation | ✅ |

---

## Future Improvements

- Add Weather or News API for multi-tool execution
- Introduce caching for API responses
- Replace rule-based planner with a live LLM when quotas allow
- Add REST API or web UI interface

---

## Conclusion

This project demonstrates a complete AI Operations workflow with clear agent separation, real API usage, and reliable local execution.  
The system is designed to be extensible and production-ready with minimal changes.
